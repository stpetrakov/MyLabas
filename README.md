# Сравнение стеков
## Практическая работа 2. "Сравнение скорости работы динамического массива и односвязного списка" 
[ссылка на задание](https://github.com/VTroyanGolovyan/MiptAaDS/blob/main/2024/Labs/Lab2Stacks/README.md)

***Tест 1:*** \
Я проверил оба стека на 100 тестах (а почему бы и нет?).
Оказалось, что стек, написанный на списке, в среднем
работает в 10 раз дольше, чем стек, написанный на массиве. \
В среднем тесты отработали за _0.1788_ и _0.0172_ секунд соответсвенно.

***Tест 2:*** \
Я также проверил оба стека на 100 тестах.
Оказалось, что стек, написанный на списке, в среднем
работает в 11 раз дольше, чем стек, написанный на массиве. \
В среднем тесты отработали за _0.18189_ и _0.01763_ секунд соответсвенно.

***Tест 3:*** \
Я также проверил оба стека на 100 тестах (а почему бы и нет?).
В этом тесте выяснилось, что стек, написанный на списке, в среднем
работает в 3,5 раза дольше, чем стек, написанный на массиве. Это очень ощутимая
разница, по сравнению с предыдущими тестами.\
В среднем тесты отработали за _0.02438_ и _0.08174_ секунд соответсвенно.

***Tест 4:***\
Динамика: \
![image](https://github.com/stpetrakov/Stacks-compare/assets/142399633/539c3d49-60bc-408e-ba5d-d858316bb7a5)
Список: \
![image](https://github.com/stpetrakov/Stacks-compare/assets/142399633/d50136f7-5e85-4848-a075-e74b89c66aa0)

*Примечание: оба графика были построены с помощью кода на python. Ниже написан псевдокод* 
```python
plt.plot(n_values, time_values, label='Время выполнения')
plt.xlabel('Число вставок (n)')
plt.ylabel('Время (секунды)')
plt.title('Зависимость времени выполнения от числа вставок')
plt.legend()
plt.show()
```


***Вывод***\
Поработав с двумя стеками я могу смело сказать, что стек, написанный на динамическом массиве быстрее и приятнее в написании, нежели стек на списках.
