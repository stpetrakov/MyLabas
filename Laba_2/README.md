# Сравнение стеков
## Практическая работа 2. "Сравнение скорости работы динамического массива и односвязного списка" 
[ссылка на задание](https://github.com/VTroyanGolovyan/MiptAaDS/blob/main/2024/Labs/Lab2Stacks/README.md)

***Tест 1:*** \
Я проверил оба стека на 100 тестах (а почему бы и нет?).
Оказалось, что стек, написанный на списке, в среднем
работает в 10 раз дольше, чем стек, написанный на массиве. \
В среднем тесты отработали за _0.1788_ и _0.0172_ секунд соответсвенно.

***Tест 2:*** \
Я также проверил оба стека на 100 тестах.
Оказалось, что стек, написанный на списке, в среднем
работает в 11 раз дольше, чем стек, написанный на массиве. \
В среднем тесты отработали за _0.18189_ и _0.01763_ секунд соответсвенно.

***Tест 3:*** \
Я также проверил оба стека на 100 тестах (а почему бы и нет?).
В этом тесте выяснилось, что стек, написанный на списке, в среднем
работает в 3,5 раза дольше, чем стек, написанный на массиве. Это очень ощутимая
разница, по сравнению с предыдущими тестами.\
В среднем тесты отработали за _0.02438_ и _0.08174_ секунд соответсвенно.

***Tест 4:***\
Динамика: \
![image](![image](https://github.com/stpetrakov/MyLabas/assets/142399633/0bc7e038-1626-43ea-b373-a2a40e6ac35f)


Список: \
![image](![image](https://github.com/stpetrakov/MyLabas/assets/142399633/403d952e-8e13-4a2c-9779-8c775cd1df8a)


*Примечание: оба графика были построены с помощью кода на python. Ниже написан псевдокод* 
```python
plt.plot(n_values, time_values, label='Время выполнения')
plt.xlabel('Число вставок (n)')
plt.ylabel('Время (секунды)')
plt.title('Зависимость времени выполнения от числа вставок')
plt.legend()
plt.show()
```


***Вывод***\
Поработав с двумя стеками я могу смело сказать, что стек, написанный на динамическом массиве быстрее и приятнее в написании, нежели стек на списках.
