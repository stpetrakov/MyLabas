# Сравнение стеков
## Практическая работа 2. "Сравнение скорости работы динамического массива и односвязного списка" 
[ссылка на задание](https://github.com/VTroyanGolovyan/MiptAaDS/blob/main/2024/Labs/Lab2Stacks/README.md)

***Tест 1:*** \
Я проверил оба стека на 100 тестах (а почему бы и нет?).
Оказалось, что стек, написанный на списке, в среднем
работает в 10 раз дольше, чем стек, написанный на массиве. \
В среднем тесты отработали за _0.1788_ и _0.0172_ секунд соответсвенно.

***Tест 2:*** \
Я также проверил оба стека на 100 тестах.
Оказалось, что стек, написанный на списке, в среднем
работает в 11 раз дольше, чем стек, написанный на массиве. \
В среднем тесты отработали за _0.18189_ и _0.01763_ секунд соответсвенно.

***Tест 3:*** \
Я также проверил оба стека на 100 тестах (а почему бы и нет?).
В этом тесте выяснилось, что стек, написанный на списке, в среднем
работает в 3,5 раза дольше, чем стек, написанный на массиве. Это очень ощутимая
разница, по сравнению с предыдущими тестами.\
В среднем тесты отработали за _0.02438_ и _0.08174_ секунд соответсвенно.

***Tест 4:***\
Динамика: \
![image](https://github.com/stpetrakov/MyLabas/assets/142399633/0bc7e038-1626-43ea-b373-a2a40e6ac35f)


Список: \
![image](https://github.com/stpetrakov/MyLabas/assets/142399633/403d952e-8e13-4a2c-9779-8c775cd1df8a)


*Примечание: оба графика были построены с помощью кода на python. Ниже написан псевдокод* 
```python
plt.plot(n_values, time_values, label='Время выполнения')
plt.xlabel('Число вставок (n)')
plt.ylabel('Время (секунды)')
plt.title('Зависимость времени выполнения от числа вставок')
plt.legend()
plt.show()
```


***Вывод***\
Я получил, что стек на динамическом массиве работает быстрее стека на списке. Это происходит по нескольким причинам:
1) *Локальность памяти:* Динамический стек реализован с использованием массива, поэтому все элементы располагаются в памяти последовательно. В стеке на списке они расположены в произвольном порядке.
2) *Меньшее количество аллокаций:* В динамическом стеке аллокации используются довольно редко, тем более на больших числах. К примеру, после 1е6 операций push мы перевыделим память всего 20 раз. Но в стеке на списке каждая операция push выделяет память. Из-за этого стек на списке работает дольше.
3) *Простота операций:* В динамическом стеке push и pop никак не затрагивают память (за исключением расширения/сужения). В стеке на списках она затрагивается каждый раз, поэтому этот тип стека работает дольше.
